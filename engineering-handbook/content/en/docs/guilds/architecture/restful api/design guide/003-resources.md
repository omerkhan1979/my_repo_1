---
title: "Resources"
linkTitle: "Resources"
weight: 3
date: 2021-11-01
description: >
   How to design the resources your API manages

---

Takeoff APIs should be centered on nouns. This is one of the core tenants of
[Googleâ€™s policy](https://google.aip.dev/121) and is generally how
[RESTful](https://en.wikipedia.org/wiki/Representational_state_transfer) systems
are designed.

Resource oriented APIs should form hierarchies. The hierarchies are used to form URLs.
The hierarchy is composed of collections (the "types" of things that exist in
the API) and resources (instances of those types).

Hierarchy should be modeled as a series of strong `has-a` relationships. These
relationships should imply the removal of a parent including the removal of
child resources. For example, if an API had publishers (`/publishers/123`) and
publications (`/publishers/123/publications/456`), the removal of the publisher
would include removing the publication.

Hierarchies should not be used to hold
[aggregations](https://en.wikipedia.org/wiki/Object_composition#Aggregation). As
an example, if publications also had authors who may be published by different
publishers, it would be incorrect to model `/publishers/123/authors` as removing
the publisher would not mean the author stops existing. It would likely be more
correct to model some sort of "publishingContracts" collection between the
publisher and author or rely on linking the two together through the publication
resource.

See [Google AIP 122](https://google.aip.dev/122) for a more in-depth overview of
these concepts.

A sample hierarchy of brands and their locations might be structured like this:

- `/brands` is a collection of brands
- `/brands/123` is a specific instance of a brand with the name 123
- `/brands/123/locations` is the collection of locations that belong to brand 123.

The collection names that exist in an API hierarchy should be derived from
terminology regularly used in support of Takeoff business processes. As our APIs
expand their scope care should be taken to update the list of [shared
terminology]({{< relref path="009-terminology.md" >}}) with the new concepts being added.

Follow these constraints when designing your collection scheme:

- Collections must use American English names and spelling
  - **Good**: `/colors/red`
  - **Bad:** `/colours/red`
- Collections must be plural nouns
  - **Good:** `/colors/red`
  - **Bad:** `/color/red`
  - **Bad:** `/create-color/red`
- Collections must match `/[a-z][a-zA-Z0-9]*/`, in other words: start with a
  lowercase letter and use camelCase to join words together
  - **Good:** `/osrLifts`
  - **Bad:** `/osr_lifts`, `/osr-lifts`
- Collections should prefer standard identifiers from the [common
  terminology]({{< relref path="009-terminology.md" >}}) list rather than synonyms
  - E.g. site instead of MFC
- Collections must adopt distinct names between different APIs to avoid
  creation confusion which API is responsible for handling activity around those
  resources in the collection.
  - **Good:** API 1: `/authors`, API 2: `/publishers/123/authorContracts` -- The
    author in the contract should be a _reference_ to `/authors/123` from API 1.
  - **Bad:** API 1: `/authors`, API 2: `/publishers/123/authors` -- If you need
    to create an author which do you use?

{{% alert title="Warning" color="warning" %}}

The above guidance of keeping collections unique might be difficult to meet
currently. If you have trouble with this reach out to API guild so we can
re-evaluate or provide suggestions.

{{% /alert %}}

The resources that exist in your API are instances of the collection they are
part of. These resources are referred to by name.

Follow these constraints when designing your resources:

- Resource names should be composed of characters acceptable by the DNS naming
  specification
- Resource names should avoid using characters that would require escaping
  - **Good:** `/articles/my-50-percent-chance-at-winning`
  - **Bad:** `/articles/my-50%25-chance-at-winning`
- For resource names that may be set by users, the format must be
  documented.
  - For example: your endpoint might state "name must conform to `/[a-zA-Z0-9\-]+/`".

- Resource names may be a synthetic (Automatically generated by the system). Synthetic identifiers should be generated non-sequetially, for instance using UUIDs or GUIDs.
  - **Good**: `/orders/1234-1234-1234-1234`
  - **Bad**: `/orders/1`, `/orders/2` -- leaks information to users about the size
    of the system and could lead to "scanning" the API.

- Resource naming patterns must be unique within a collection.
  - **Good**: Documenting a collection as `/orders/{order_id}`
  - **Bad**: Documenting a collection as both `/orders/a{orderId}` for one
    subset of resources and `/orders/b{orderId}` for some other subset. Should
    be different collections/parents.
- References to a resource should be done _without_ referencing an API version
  - **Good**: `/orders/123`
  - **Bad**: `/v1/orders/123`

## Common resource heirarchies

As mentioned above, resource names should be derived from common [terminology]({{< relref path="009-terminology.md" >}}). The two most common resources heirarchies are sites (`/sites/SITE_ID/resourceTypeHere`) and retailers (`/retailers/RETAILER_ID/resourceTypeHere`). We should expect to see the vast majority of resources living within the site heirachy and relatively few under the retailer.

The heirarchy should not have sites nested under retailers (`/retailers/X/sites/Y`). Site IDs are unique to a retailer and adding the extra identification only increases complexity. Consider it analogous to [GCP Projects and organizations](https://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy). Because every GCP project is unique, they do not end up adding it to their resource names, instead they have names like `/projects/my-cool-project/topics/my-topic`.

Once you've designed your resource heirarchy, you need to start thinking about your resource's [behavior](./004-behavior.md).

